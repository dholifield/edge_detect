<!DOCTYPE html>
<html>

<head>
    <meta charset="UTF-8">
    <title>Headlight Cutline Detection</title>
    <style>
        body {
            background: #111;
            margin: 0;
            display: flex;
            justify-content: center;
            align-items: center;
            height: 100vh;
            overflow: hidden;
        }

        canvas {
            image-rendering: pixelated;
            margin: 0 auto;
            display: block;
            /* preserve intrinsic aspect ratio; allow scaling down but not stretching */
            width: auto;
            /* never force to fill container width */
            height: auto;
            max-width: 100vw;
            /* scale down to viewport width if needed */
            max-height: 100vh;
            /* or viewport height */
        }

        /* Controls panel */
        #settingsBtn {
            position: fixed;
            right: 12px;
            top: 12px;
            z-index: 10000;
            background: rgba(0, 0, 0, 0.6);
            color: white;
            border: none;
            padding: 8px 10px;
            border-radius: 6px;
            font-size: 36px;
            cursor: pointer;
        }

        #controlsPanel {
            position: fixed;
            left: 8px;
            top: 8px;
            background: rgba(0, 0, 0, 0.6);
            color: white;
            padding: 8px;
            font-family: sans-serif;
            font-size: 36px;
            border-radius: 6px;
            z-index: 9999;
            display: none;
            max-width: calc(100vw - 40px);
        }

        /* Larger, touch-friendly slider styling */
        #controlsPanel input[type="range"] {
            -webkit-appearance: none;
            appearance: none;
            width: 100%;
            height: 34px;
            /* visual area reserved for the control */
            margin: 8px 0;
            background: transparent;
        }

        #controlsPanel input[type="range"]::-webkit-slider-runnable-track {
            height: 10px;
            background: rgba(255, 255, 255, 0.15);
            border-radius: 8px;
        }

        #controlsPanel input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            width: 30px;
            height: 30px;
            border-radius: 50%;
            background: white;
            border: 3px solid rgba(0, 0, 0, 0.6);
            margin-top: -10px;
            box-shadow: 0 1px 3px rgba(0, 0, 0, 0.4);
        }

        #controlsPanel input[type="range"]::-moz-range-track {
            height: 10px;
            background: rgba(255, 255, 255, 0.15);
            border-radius: 8px;
        }

        #controlsPanel input[type="range"]::-moz-range-thumb {
            width: 30px;
            height: 30px;
            border-radius: 50%;
            background: white;
            border: 3px solid rgba(0, 0, 0, 0.6);
            box-shadow: 0 1px 3px rgba(0, 0, 0, 0.4);
        }

        @media (max-width: 600px) {

            #controlsPanel input[type="range"]::-webkit-slider-thumb,
            #controlsPanel input[type="range"]::-moz-range-thumb {
                width: 40px;
                height: 40px;
                margin-top: -15px;
            }

            #controlsPanel input {
                width: 100%;
                box-sizing: border-box;
            }
        }
    </style>
</head>

<body>

    <video id="video" autoplay playsinline style="display:none;"></video>
    <canvas id="canvas"></canvas>
    <button id="settingsBtn">Settings</button>
    <div id="controlsPanel">
        <label>Threshold weight (0 = bottom, 1 = top):</label><br>
        <input id="thresholdWeight" type="range" min="0" max="1" step="0.01" value="0.5" style="width:140px"><br>
        <label style="margin-top:6px; display:block;">Dot separation (0 = together, 1 = full height):</label>
        <input id="dotGap" type="range" min="0.01" max="1" step="0.01" value="0.2" style="width:140px"><br>
        <label style="margin-top:6px; display:block;">Blur radius (integer):</label>
        <input id="blurRadius" type="number" min="0" max="50" value="5" step="1" style="width:200px; height:30px"><br>
        <label style="margin-top:6px; display:block;">minSize (edge pixels):</label>
        <input id="minSize" type="number" min="0" max="100000" value="1000" step="1" style="width:200px; height:30px">
    </div>

    <script>
        const video = document.getElementById("video");
        const canvas = document.getElementById("canvas");
        const ctx = canvas.getContext("2d", { willReadFrequently: true });
        // dot gap is controlled by slider (no interactive dragging)

        async function startCamera() {
            const stream = await navigator.mediaDevices.getUserMedia({
                video: { facingMode: "environment" }
            });
            video.srcObject = stream;

            video.onloadedmetadata = () => {
                canvas.width = video.videoWidth;
                canvas.height = video.videoHeight;
                updateCanvasSize();
                requestAnimationFrame(processFrame);
            };
        }

        // Resize canvas CSS display size to maximally fill viewport while preserving aspect ratio
        function updateCanvasSize() {
            if (!canvas.width || !canvas.height) return;
            const vw = window.innerWidth;
            const vh = window.innerHeight;
            const aspect = canvas.width / canvas.height;
            let displayWidth, displayHeight;
            if (vw / vh > aspect) {
                // viewport is wider than camera: constrain by height
                displayHeight = vh;
                displayWidth = Math.round(vh * aspect);
            } else {
                // viewport is taller/narrower: constrain by width
                displayWidth = vw;
                displayHeight = Math.round(vw / aspect);
            }
            canvas.style.width = displayWidth + 'px';
            canvas.style.height = displayHeight + 'px';
            // center without creating extra page width
            canvas.style.margin = '0 auto';
        }

        window.addEventListener('resize', updateCanvasSize);
        window.addEventListener('orientationchange', updateCanvasSize);

        // --- utility to get grayscale at pixel ---
        // If `radius` > 0, average luminance over a (2*radius+1) square centered at (x,y).
        // data: ImageData.data (RGBA), width: image width in pixels
        function getGrayAt(data, x, y, width, radius = 0) {
            if (!radius) {
                const i = (y * width + x) * 4;
                const r = data[i];
                const g = data[i + 1];
                const b = data[i + 2];
                return 0.299 * r + 0.587 * g + 0.114 * b;
            }

            const totalPixels = data.length / 4;
            const height = Math.max(1, Math.floor(totalPixels / width));

            let sum = 0;
            let count = 0;

            const x0 = Math.max(0, x - radius);
            const x1 = Math.min(width - 1, x + radius);
            const y0 = Math.max(0, y - radius);
            const y1 = Math.min(height - 1, y + radius);

            for (let yy = y0; yy <= y1; yy++) {
                for (let xx = x0; xx <= x1; xx++) {
                    const idx = (yy * width + xx) * 4;
                    const r = data[idx];
                    const g = data[idx + 1];
                    const b = data[idx + 2];
                    sum += 0.299 * r + 0.587 * g + 0.114 * b;
                    count++;
                }
            }

            return count ? (sum / count) : 0;
        }

        // separable Gaussian blur with variable integer radius
        // radius: integer >= 0. Kernel size = 2*radius+1. Returns Uint8ClampedArray.
        function gaussianBlur(gray, w, h, radius = 1) {
            if (!radius || radius <= 0) return gray;

            const r = Math.max(1, Math.floor(radius));
            const ksize = 2 * r + 1;
            const sigma = Math.max(0.5, r / 2);
            const twoSigma2 = 2 * sigma * sigma;

            const kernel = new Float64Array(ksize);
            let ksum = 0;
            for (let i = -r; i <= r; i++) {
                const v = Math.exp(-(i * i) / twoSigma2);
                kernel[i + r] = v;
                ksum += v;
            }
            for (let i = 0; i < ksize; i++) kernel[i] /= ksum;

            // horizontal pass into temp (float)
            const temp = new Float64Array(w * h);
            for (let y = 0; y < h; y++) {
                for (let x = 0; x < w; x++) {
                    let acc = 0;
                    for (let k = -r; k <= r; k++) {
                        const sx = Math.min(w - 1, Math.max(0, x + k));
                        acc += gray[y * w + sx] * kernel[k + r];
                    }
                    temp[y * w + x] = acc;
                }
            }

            // vertical pass into output (Uint8ClampedArray)
            const out = new Uint8ClampedArray(w * h);
            for (let x = 0; x < w; x++) {
                for (let y = 0; y < h; y++) {
                    let acc = 0;
                    for (let k = -r; k <= r; k++) {
                        const sy = Math.min(h - 1, Math.max(0, y + k));
                        acc += temp[sy * w + x] * kernel[k + r];
                    }
                    out[y * w + x] = Math.round(acc);
                }
            }

            return out;
        }

        function processFrame() {
            const w = canvas.width;
            const h = canvas.height;

            // Draw live camera frame
            ctx.drawImage(video, 0, 0);

            // Read pixel data for processing
            const frame = ctx.getImageData(0, 0, w, h);
            const data = frame.data;

            // --- Compute reference dot positions ---
            const dotX = Math.floor(w / 2);

            // read gap from control (0.0..1.0), default 0.5
            const gapEl = document.getElementById('dotGap');
            const gap = gapEl ? (parseFloat(gapEl.value) || 0.5) : 0.5;
            // compute dot positions symmetrically around center
            const dotY1 = Math.floor(h * (0.5 - gap / 2));
            const dotY2 = Math.floor(h * (0.5 + gap / 2));
            // --- Compute grayscale threshold from dots (weighted by slider) ---
            const g1 = getGrayAt(data, dotX, dotY1, w, 4);
            const g2 = getGrayAt(data, dotX, dotY2, w, 4);
            const twEl = document.getElementById('thresholdWeight');
            const weight = twEl ? (isFinite(+twEl.value) ? +twEl.value : 0.5) : 0.5;
            // weight==1 => threshold = g1 (top); weight==0 => threshold = g2 (bottom)
            const threshold = g1 * weight + g2 * (1 - weight);

            // --- Prepare grayscale buffer ---
            const gray = new Uint8ClampedArray(w * h);

            for (let i = 0; i < data.length; i += 4) {
                const r = data[i];
                const g = data[i + 1];
                const b = data[i + 2];
                const gv = 0.299 * r + 0.587 * g + 0.114 * b;
                gray[i / 4] = gv;
                // gray[i / 4] = (gv > threshold) ? 255 : 0;
            }

            // read blur radius from control (integer); fallback to 5
            const blurRadiusEl = document.getElementById('blurRadius');
            const blurRadius = blurRadiusEl ? (parseInt(blurRadiusEl.value, 10) || 0) : 5;
            let blurred = gaussianBlur(gray, w, h, blurRadius);

            // binarize based on threshold
            const image = new Uint8ClampedArray(w * h);
            for (let i = 0; i < w * h; i++) image[i] = (blurred[i] > threshold) ? 255 : 0;

            // --- Sobel edge detection for contour-style lines ---
            const sobelX = [-1, 0, 1, -2, 0, 2, -1, 0, 1];
            const sobelY = [-1, -2, -1, 0, 0, 0, 1, 2, 1];

            // ---- 1. Build a binary edge map ----
            const edgeMap = new Uint8Array(w * h);

            for (let y = 1; y < h - 1; y++) {
                for (let x = 1; x < w - 1; x++) {
                    let gx = 0, gy = 0;
                    let idx = 0;

                    for (let ky = -1; ky <= 1; ky++) {
                        for (let kx = -1; kx <= 1; kx++) {
                            const pixel = image[(y + ky) * w + (x + kx)];
                            gx += pixel * sobelX[idx];
                            gy += pixel * sobelY[idx];
                            idx++;
                        }
                    }

                    const mag = Math.sqrt(gx * gx + gy * gy);

                    // Binary edge map (tunable)
                    edgeMap[y * w + x] = mag > 200 ? 1 : 0;
                }
            }

            // ---- 2. Connected-component filtering ----
            const visited = new Uint8Array(w * h);
            // read minSize from control (fallback to 100)
            const minSizeEl = document.getElementById('minSize');
            const minSize = minSizeEl ? (parseInt(minSizeEl.value, 10) || 0) : 100;

            ctx.lineWidth = 1;
            ctx.strokeStyle = "red";

            ctx.beginPath();

            for (let y = 1; y < h - 1; y++) {
                for (let x = 1; x < w - 1; x++) {

                    const i = y * w + x;
                    if (!edgeMap[i] || visited[i]) continue;

                    // BFS flood fill for connected edge region
                    const queue = [[x, y]];
                    const pixels = [];

                    visited[i] = 1;

                    while (queue.length > 0) {
                        const [cx, cy] = queue.shift();
                        pixels.push([cx, cy]);

                        // explore neighbors
                        for (let dy = -1; dy <= 1; dy++) {
                            for (let dx = -1; dx <= 1; dx++) {
                                if (dx === 0 && dy === 0) continue;

                                const nx = cx + dx, ny = cy + dy;
                                if (nx < 0 || ny < 0 || nx >= w || ny >= h) continue;

                                const ni = ny * w + nx;
                                if (!visited[ni] && edgeMap[ni]) {
                                    visited[ni] = 1;
                                    queue.push([nx, ny]);
                                }
                            }
                        }
                    }

                    // ---- FILTER OUT SMALL EDGE BLOBS ----
                    if (pixels.length < minSize) continue;

                    // Draw the component as contour-like strokes
                    for (const [px, py] of pixels) {
                        ctx.moveTo(px, py);
                        ctx.lineTo(px + 1, py + 1);
                    }
                }
            }

            ctx.stroke();

            // --- Draw reference dots ---
            ctx.fillStyle = "black";
            ctx.beginPath();
            ctx.arc(dotX, dotY1, 6, 0, Math.PI * 2);
            ctx.arc(dotX, dotY2, 6, 0, Math.PI * 2);
            ctx.fill();
            ctx.beginPath();
            ctx.fillStyle = "white";
            ctx.arc(dotX, dotY1, 3, 0, Math.PI * 2);
            ctx.arc(dotX, dotY2, 3, 0, Math.PI * 2);
            ctx.fill();

            requestAnimationFrame(processFrame);
        }

        startCamera();

        // settings panel toggle
        const settingsBtn = document.getElementById('settingsBtn');
        const controlsPanel = document.getElementById('controlsPanel');
        if (settingsBtn && controlsPanel) {
            settingsBtn.addEventListener('click', () => {
                controlsPanel.style.display = controlsPanel.style.display === 'block' ? 'none' : 'block';
            });
        }
    </script>

</body>

</html>