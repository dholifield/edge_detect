<!DOCTYPE html>
<html>

<head>
    <meta charset="UTF-8">
    <title>Headlight Cutline Detection</title>
    <style>
        body {
            background: #111;
            margin: 0;
            display: flex;
            justify-content: center;
        }

        canvas {
            image-rendering: pixelated;
            margin-top: 20px;
        }
    </style>
</head>

<body>

    <video id="video" autoplay playsinline style="display:none;"></video>
    <canvas id="canvas"></canvas>
    <div
        style="position:fixed; left:8px; top:8px; background:rgba(0,0,0,0.6); color:white; padding:6px; font-family:sans-serif; font-size:12px; border-radius:6px; z-index:9999;">
        <label>Threshold weight (0 = top, 100 = bottom):</label><br>
        <input id="thresholdWeight" type="number" min="0" max="100" value="50" step="1" style="width:68px"><br>
        <!-- Dot gap slider removed; use interactive dragging to position dots -->
        <label style="margin-top:6px; display:block;">Blur radius (integer):</label>
        <input id="blurRadius" type="number" min="0" max="50" value="10" step="1" style="width:68px"><br>
        <label style="margin-top:6px; display:block;">minSize (edge pixels):</label>
        <input id="minSize" type="number" min="0" max="100000" value="1000" step="1" style="width:80px">
    </div>

    <script>
        const video = document.getElementById("video");
        const canvas = document.getElementById("canvas");
        const ctx = canvas.getContext("2d", { willReadFrequently: true });
        // interactive dot dragging state
        let draggingDot = null; // 'top' or 'bottom' or null
        let dotY1_override = null;
        let dotY2_override = null;

        async function startCamera() {
            const stream = await navigator.mediaDevices.getUserMedia({
                video: { facingMode: "environment" }
            });
            video.srcObject = stream;

            video.onloadedmetadata = () => {
                canvas.width = video.videoWidth;
                canvas.height = video.videoHeight;
                requestAnimationFrame(processFrame);
            };
        }

        // --- utility to get grayscale at pixel ---
        // If `radius` > 0, average luminance over a (2*radius+1) square centered at (x,y).
        // data: ImageData.data (RGBA), width: image width in pixels
        function getGrayAt(data, x, y, width, radius = 0) {
            if (!radius) {
                const i = (y * width + x) * 4;
                const r = data[i];
                const g = data[i + 1];
                const b = data[i + 2];
                return 0.299 * r + 0.587 * g + 0.114 * b;
            }

            const totalPixels = data.length / 4;
            const height = Math.max(1, Math.floor(totalPixels / width));

            let sum = 0;
            let count = 0;

            const x0 = Math.max(0, x - radius);
            const x1 = Math.min(width - 1, x + radius);
            const y0 = Math.max(0, y - radius);
            const y1 = Math.min(height - 1, y + radius);

            for (let yy = y0; yy <= y1; yy++) {
                for (let xx = x0; xx <= x1; xx++) {
                    const idx = (yy * width + xx) * 4;
                    const r = data[idx];
                    const g = data[idx + 1];
                    const b = data[idx + 2];
                    sum += 0.299 * r + 0.587 * g + 0.114 * b;
                    count++;
                }
            }

            return count ? (sum / count) : 0;
        }

        // separable Gaussian blur with variable integer radius
        // radius: integer >= 0. Kernel size = 2*radius+1. Returns Uint8ClampedArray.
        function gaussianBlur(gray, w, h, radius = 1) {
            if (!radius || radius <= 0) return gray;

            const r = Math.max(1, Math.floor(radius));
            const ksize = 2 * r + 1;
            const sigma = Math.max(0.5, r / 2);
            const twoSigma2 = 2 * sigma * sigma;

            const kernel = new Float64Array(ksize);
            let ksum = 0;
            for (let i = -r; i <= r; i++) {
                const v = Math.exp(-(i * i) / twoSigma2);
                kernel[i + r] = v;
                ksum += v;
            }
            for (let i = 0; i < ksize; i++) kernel[i] /= ksum;

            // horizontal pass into temp (float)
            const temp = new Float64Array(w * h);
            for (let y = 0; y < h; y++) {
                for (let x = 0; x < w; x++) {
                    let acc = 0;
                    for (let k = -r; k <= r; k++) {
                        const sx = Math.min(w - 1, Math.max(0, x + k));
                        acc += gray[y * w + sx] * kernel[k + r];
                    }
                    temp[y * w + x] = acc;
                }
            }

            // vertical pass into output (Uint8ClampedArray)
            const out = new Uint8ClampedArray(w * h);
            for (let x = 0; x < w; x++) {
                for (let y = 0; y < h; y++) {
                    let acc = 0;
                    for (let k = -r; k <= r; k++) {
                        const sy = Math.min(h - 1, Math.max(0, y + k));
                        acc += temp[sy * w + x] * kernel[k + r];
                    }
                    out[y * w + x] = Math.round(acc);
                }
            }

            return out;
        }

        function processFrame() {
            const w = canvas.width;
            const h = canvas.height;

            // Draw live camera frame
            ctx.drawImage(video, 0, 0);

            // Read pixel data for processing
            const frame = ctx.getImageData(0, 0, w, h);
            const data = frame.data;

            // --- Compute reference dot positions ---
            const dotX = Math.floor(w / 2);

            // default gap used when dots not set by dragging
            const gap = 0.5;

            // Allow interactive overrides via dragging: if override is set use that position
            let dotY1 = dotY1_override !== null ? dotY1_override : Math.floor(h * (0.5 - gap / 2));
            let dotY2 = dotY2_override !== null ? dotY2_override : Math.floor(h * (0.5 + gap / 2));
            // --- Compute grayscale threshold from dots (weighted by slider) ---
            const g1 = getGrayAt(data, dotX, dotY1, w, 4);
            const g2 = getGrayAt(data, dotX, dotY2, w, 4);
            const twEl = document.getElementById('thresholdWeight');
            const weight = twEl ? (parseFloat(twEl.value) / 100.0) : 0.5;
            // weight==0 => threshold = g1 (top); weight==1 => threshold = g2 (bottom)
            const threshold = g1 * (1 - weight) + g2 * weight;

            // --- Prepare grayscale buffer ---
            const gray = new Uint8ClampedArray(w * h);

            for (let i = 0; i < data.length; i += 4) {
                const r = data[i];
                const g = data[i + 1];
                const b = data[i + 2];
                const gv = 0.299 * r + 0.587 * g + 0.114 * b;
                gray[i / 4] = gv;
                // gray[i / 4] = (gv > threshold) ? 255 : 0;
            }

            // read blur radius from control (integer); fallback to 5
            const blurRadiusEl = document.getElementById('blurRadius');
            const blurRadius = blurRadiusEl ? (parseInt(blurRadiusEl.value, 10) || 0) : 5;
            let blurred = gaussianBlur(gray, w, h, blurRadius);

            // binarize based on threshold
            const image = new Uint8ClampedArray(w * h);
            for (let i = 0; i < w * h; i++) image[i] = (blurred[i] > threshold) ? 255 : 0;

            // --- Sobel edge detection for contour-style lines ---
            const sobelX = [-1, 0, 1, -2, 0, 2, -1, 0, 1];
            const sobelY = [-1, -2, -1, 0, 0, 0, 1, 2, 1];

            // ---- 1. Build a binary edge map ----
            const edgeMap = new Uint8Array(w * h);

            for (let y = 1; y < h - 1; y++) {
                for (let x = 1; x < w - 1; x++) {
                    let gx = 0, gy = 0;
                    let idx = 0;

                    for (let ky = -1; ky <= 1; ky++) {
                        for (let kx = -1; kx <= 1; kx++) {
                            const pixel = image[(y + ky) * w + (x + kx)];
                            gx += pixel * sobelX[idx];
                            gy += pixel * sobelY[idx];
                            idx++;
                        }
                    }

                    const mag = Math.sqrt(gx * gx + gy * gy);

                    // Binary edge map (tunable)
                    edgeMap[y * w + x] = mag > 200 ? 1 : 0;
                }
            }

            // ---- 2. Connected-component filtering ----
            const visited = new Uint8Array(w * h);
            // read minSize from control (fallback to 100)
            const minSizeEl = document.getElementById('minSize');
            const minSize = minSizeEl ? (parseInt(minSizeEl.value, 10) || 0) : 100;

            ctx.lineWidth = 1;
            ctx.strokeStyle = "red";

            ctx.beginPath();

            for (let y = 1; y < h - 1; y++) {
                for (let x = 1; x < w - 1; x++) {

                    const i = y * w + x;
                    if (!edgeMap[i] || visited[i]) continue;

                    // BFS flood fill for connected edge region
                    const queue = [[x, y]];
                    const pixels = [];

                    visited[i] = 1;

                    while (queue.length > 0) {
                        const [cx, cy] = queue.shift();
                        pixels.push([cx, cy]);

                        // explore neighbors
                        for (let dy = -1; dy <= 1; dy++) {
                            for (let dx = -1; dx <= 1; dx++) {
                                if (dx === 0 && dy === 0) continue;

                                const nx = cx + dx, ny = cy + dy;
                                if (nx < 0 || ny < 0 || nx >= w || ny >= h) continue;

                                const ni = ny * w + nx;
                                if (!visited[ni] && edgeMap[ni]) {
                                    visited[ni] = 1;
                                    queue.push([nx, ny]);
                                }
                            }
                        }
                    }

                    // ---- FILTER OUT SMALL EDGE BLOBS ----
                    if (pixels.length < minSize) continue;

                    // Draw the component as contour-like strokes
                    for (const [px, py] of pixels) {
                        ctx.moveTo(px, py);
                        ctx.lineTo(px + 1, py + 1);
                    }
                }
            }

            ctx.stroke();

            // --- Draw reference dots ---
            ctx.fillStyle = "black";
            ctx.beginPath();
            ctx.arc(dotX, dotY1, 6, 0, Math.PI * 2);
            ctx.arc(dotX, dotY2, 6, 0, Math.PI * 2);
            ctx.fill();
            ctx.beginPath();
            ctx.fillStyle = "white";
            ctx.arc(dotX, dotY1, 3, 0, Math.PI * 2);
            ctx.arc(dotX, dotY2, 3, 0, Math.PI * 2);
            ctx.fill();

            // when dragging, draw a small highlight line to show draggable state
            if (draggingDot) {
                ctx.strokeStyle = 'red';
                ctx.lineWidth = 2;
                ctx.beginPath();
                if (draggingDot === 'top') {
                    ctx.moveTo(0, dotY1); ctx.lineTo(w, dotY1);
                } else if (draggingDot === 'bottom') {
                    ctx.moveTo(0, dotY2); ctx.lineTo(w, dotY2);
                }
                ctx.stroke();
            }

            requestAnimationFrame(processFrame);
        }

        startCamera();

        // Pointer event handlers to drag the sample dots vertically
        canvas.addEventListener('pointerdown', (ev) => {
            const rect = canvas.getBoundingClientRect();
            const x = Math.round((ev.clientX - rect.left) * (canvas.width / rect.width));
            const y = Math.round((ev.clientY - rect.top) * (canvas.height / rect.height));
            // compute current dot positions as in processFrame (approx)
            const dotX = Math.floor(canvas.width / 2);
            const gap = 0.5;
            const dy1 = dotY1_override !== null ? dotY1_override : Math.floor(canvas.height * (0.5 - gap / 2));
            const dy2 = dotY2_override !== null ? dotY2_override : Math.floor(canvas.height * (0.5 + gap / 2));
            const d1 = Math.hypot(x - dotX, y - dy1);
            const d2 = Math.hypot(x - dotX, y - dy2);
            const radius = 12; // clickable radius
            const minSep = 1; // minimum pixel separation between top and bottom
            if (d1 <= radius && d1 <= d2) {
                draggingDot = 'top';
                let newY = Math.max(0, Math.min(canvas.height - 1, y));
                // ensure top stays above bottom
                if (dotY2_override !== null) newY = Math.min(newY, dotY2_override - minSep);
                else {
                    // if no bottom override, ensure it stays above default bottom
                    const defaultBottom = Math.floor(canvas.height * (0.5 + gap / 2));
                    newY = Math.min(newY, defaultBottom - minSep);
                }
                dotY1_override = newY;
                canvas.setPointerCapture(ev.pointerId);
            } else if (d2 <= radius) {
                draggingDot = 'bottom';
                let newY = Math.max(0, Math.min(canvas.height - 1, y));
                // ensure bottom stays below top
                if (dotY1_override !== null) newY = Math.max(newY, dotY1_override + minSep);
                else {
                    const defaultTop = Math.floor(canvas.height * (0.5 - gap / 2));
                    newY = Math.max(newY, defaultTop + minSep);
                }
                dotY2_override = newY;
                canvas.setPointerCapture(ev.pointerId);
            }
        });

        canvas.addEventListener('pointermove', (ev) => {
            if (!draggingDot) return;
            const rect = canvas.getBoundingClientRect();
            const y = Math.round((ev.clientY - rect.top) * (canvas.height / rect.height));
            const minSep = 1;
            const default_sep = 0.2;
            if (draggingDot === 'top') {
                let newY = Math.max(0, Math.min(canvas.height - 1, y));
                // don't allow top to cross bottom
                if (dotY2_override !== null) newY = Math.min(newY, dotY2_override - minSep);
                else newY = Math.min(newY, Math.floor(canvas.height * (0.5 + default_sep / 2)) - minSep);
                dotY1_override = newY;
            } else if (draggingDot === 'bottom') {
                let newY = Math.max(0, Math.min(canvas.height - 1, y));
                if (dotY1_override !== null) newY = Math.max(newY, dotY1_override + minSep);
                else newY = Math.max(newY, Math.floor(canvas.height * (0.5 - default_sep / 2)) + minSep);
                dotY2_override = newY;
            }
            // we no longer update a slider; keep override positions only
        });

        canvas.addEventListener('pointerup', (ev) => {
            if (draggingDot) {
                try { canvas.releasePointerCapture(ev.pointerId); } catch (e) { }
                draggingDot = null;
                // no slider to sync; leave overrides in place
            }
        });

        canvas.addEventListener('pointercancel', (ev) => { draggingDot = null; });
    </script>

</body>

</html>